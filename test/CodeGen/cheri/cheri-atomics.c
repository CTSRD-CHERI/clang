// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py
// RUN: %cheri_purecap_cc1 %s -emit-llvm -o - | %cheri_FileCheck %s
// Check that we can generate assembly without crashing
// RUN: %cheri_purecap_cc1 %s -S -o /dev/null

// CHECK-LABEL: @main(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[RETVAL:%.*]] = alloca i32, align 4, addrspace(200)
// CHECK-NEXT:    [[P:%.*]] = alloca i32 addrspace(200)*, align [[$CAP_SIZE]], addrspace(200)
// CHECK-NEXT:    [[DOTATOMICTMP:%.*]] = alloca i64, align 8, addrspace(200)
// CHECK-NEXT:    [[ATOMIC_TEMP:%.*]] = alloca i32 addrspace(200)*, align [[$CAP_SIZE]], addrspace(200)
// CHECK-NEXT:    [[ATOMIC_TEMP1:%.*]] = alloca i32 addrspace(200)*, align [[$CAP_SIZE]], addrspace(200)
// CHECK-NEXT:    [[C:%.*]] = alloca i32 addrspace(200)*, align [[$CAP_SIZE]], addrspace(200)
// CHECK-NEXT:    [[ATOMIC_TEMP2:%.*]] = alloca i32 addrspace(200)*, align [[$CAP_SIZE]], addrspace(200)
// CHECK-NEXT:    [[DOTATOMICTMP3:%.*]] = alloca i32 addrspace(200)*, align [[$CAP_SIZE]], addrspace(200)
// CHECK-NEXT:    [[EXPECTED:%.*]] = alloca i32 addrspace(200)*, align [[$CAP_SIZE]], addrspace(200)
// CHECK-NEXT:    [[DOTATOMICTMP4:%.*]] = alloca i32 addrspace(200)*, align [[$CAP_SIZE]], addrspace(200)
// CHECK-NEXT:    [[CMPXCHG_BOOL:%.*]] = alloca i8, align 1, addrspace(200)
// CHECK-NEXT:    store i32 0, i32 addrspace(200)* [[RETVAL]], align 4
// CHECK-NEXT:    store i64 4, i64 addrspace(200)* [[DOTATOMICTMP]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = bitcast i32 addrspace(200)* addrspace(200)* [[ATOMIC_TEMP]] to i8 addrspace(200)*
// CHECK-NEXT:    [[TMP1:%.*]] = bitcast i64 addrspace(200)* [[DOTATOMICTMP]] to i8 addrspace(200)*
// CHECK-NEXT:    call void @llvm.memcpy.p200i8.p200i8.i64(i8 addrspace(200)* align [[$CAP_SIZE]] [[TMP0]], i8 addrspace(200)* align 8 [[TMP1]], i64 8, i1 false)
// CHECK-NEXT:    [[TMP2:%.*]] = bitcast i32 addrspace(200)* addrspace(200)* [[P]] to i8 addrspace(200)*
// CHECK-NEXT:    [[TMP3:%.*]] = bitcast i32 addrspace(200)* addrspace(200)* [[ATOMIC_TEMP]] to i8 addrspace(200)*
// CHECK-NEXT:    [[TMP4:%.*]] = bitcast i32 addrspace(200)* addrspace(200)* [[ATOMIC_TEMP1]] to i8 addrspace(200)*
// CHECK-NEXT:    call void @__atomic_fetch_add(i64 zeroext [[$CAP_SIZE]], i8 addrspace(200)* [[TMP2]], i8 addrspace(200)* [[TMP3]], i8 addrspace(200)* [[TMP4]], i32 signext 5)
// CHECK-NEXT:    [[TMP5:%.*]] = load i32 addrspace(200)*, i32 addrspace(200)* addrspace(200)* [[ATOMIC_TEMP1]]
// CHECK-NEXT:    [[TMP6:%.*]] = load atomic i32 addrspace(200)*, i32 addrspace(200)* addrspace(200)* [[P]] seq_cst
// CHECK-NEXT:    store i32 addrspace(200)* [[TMP6]], i32 addrspace(200)* addrspace(200)* [[ATOMIC_TEMP2]]
// CHECK-NEXT:    [[TMP7:%.*]] = load i32 addrspace(200)*, i32 addrspace(200)* addrspace(200)* [[ATOMIC_TEMP2]]
// CHECK-NEXT:    store i32 addrspace(200)* [[TMP7]], i32 addrspace(200)* addrspace(200)* [[C]]
// CHECK-NEXT:    store i32 addrspace(200)* null, i32 addrspace(200)* addrspace(200)* [[DOTATOMICTMP3]]
// CHECK-NEXT:    [[TMP8:%.*]] = load i32 addrspace(200)*, i32 addrspace(200)* addrspace(200)* [[DOTATOMICTMP3]]
// CHECK-NEXT:    store atomic i32 addrspace(200)* [[TMP8]], i32 addrspace(200)* addrspace(200)* [[P]] seq_cst
// CHECK-NEXT:    store i32 addrspace(200)* null, i32 addrspace(200)* addrspace(200)* [[EXPECTED]]
// CHECK-NEXT:    [[TMP9:%.*]] = load i32 addrspace(200)*, i32 addrspace(200)* addrspace(200)* [[C]]
// CHECK-NEXT:    store i32 addrspace(200)* [[TMP9]], i32 addrspace(200)* addrspace(200)* [[DOTATOMICTMP4]]
// CHECK-NEXT:    [[TMP10:%.*]] = bitcast i32 addrspace(200)* addrspace(200)* [[P]] to i8 addrspace(200)*
// CHECK-NEXT:    [[TMP11:%.*]] = bitcast i32 addrspace(200)* addrspace(200)* [[EXPECTED]] to i8 addrspace(200)*
// CHECK-NEXT:    [[TMP12:%.*]] = bitcast i32 addrspace(200)* addrspace(200)* [[DOTATOMICTMP4]] to i8 addrspace(200)*
// CHECK-NEXT:    [[CALL:%.*]] = call zeroext i1 @__atomic_compare_exchange(i64 zeroext [[$CAP_SIZE]], i8 addrspace(200)* [[TMP10]], i8 addrspace(200)* [[TMP11]], i8 addrspace(200)* [[TMP12]], i32 signext 5, i32 signext 5)
// CHECK-NEXT:    ret i32 0
//
int main(void) {
  _Atomic(int*) p;

  __c11_atomic_fetch_add(&p, 1, __ATOMIC_SEQ_CST);

  int *c = __c11_atomic_load(&p, __ATOMIC_SEQ_CST);

  __c11_atomic_store(&p, 0, __ATOMIC_SEQ_CST);

  int* expected = 0;
  __c11_atomic_compare_exchange_strong(&p, &expected, c, __ATOMIC_SEQ_CST, __ATOMIC_SEQ_CST);
  return 0;
}
