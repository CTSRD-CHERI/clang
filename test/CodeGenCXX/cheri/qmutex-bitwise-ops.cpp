// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py
// RUN: %cheri_purecap_cc1 %s -fno-rtti -emit-llvm -o - | FileCheck %s
// XFAIL: *

// QMutexLocker::unlock() turned into a no-op because the check in unlock()
// `(val & quintptr(1u)) == quintptr(1u)` was compiled to never true code
// after I silenced a warning

typedef __UINTPTR_TYPE__ quintptr;

extern void do_unlock();

// CHECK-LABEL: @unlock(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[VAL_ADDR:%.*]] = alloca i8 addrspace(200)*, align 16, addrspace(200)
// CHECK-NEXT:    store i8 addrspace(200)* [[VAL:%.*]], i8 addrspace(200)* addrspace(200)* [[VAL_ADDR]], align 16
// CHECK-NEXT:    [[TMP0:%.*]] = load i8 addrspace(200)*, i8 addrspace(200)* addrspace(200)* [[VAL_ADDR]], align 16
// CHECK-NEXT:    [[TMP1:%.*]] = call i8 addrspace(200)* @llvm.cheri.cap.offset.set(i8 addrspace(200)* null, i64 1)
// CHECK-NEXT:    [[TMP2:%.*]] = call i64 @llvm.cheri.cap.offset.get(i8 addrspace(200)* [[TMP0]])
// CHECK-NEXT:    [[TMP3:%.*]] = call i64 @llvm.cheri.cap.offset.get(i8 addrspace(200)* [[TMP1]])
// CHECK-NEXT:    [[AND:%.*]] = and i64 [[TMP2]], [[TMP3]]
// FIXME: we shouldn't compare val with offset set to val&1 against (uintcap_t)1 since that will always be false
// FIXME: this is wrong (it should be i8 addrspace(200)* null for both cases!)
// TODO: should uintcap_t & foo be of type ptrdiff_t and not uintcap_t?
// WRONG-NEXT:    [[TMP4:%.*]] = call i8 addrspace(200)* @llvm.cheri.cap.offset.set(i8 addrspace(200)* [[TMP0]], i64 [[AND]])
// CHECK-NEXT:    [[TMP4:%.*]] = call i8 addrspace(200)* @llvm.cheri.cap.offset.set(i8 addrspace(200)* null, i64 [[AND]])
// CHECK-NEXT:    [[TMP5:%.*]] = call i8 addrspace(200)* @llvm.cheri.cap.offset.set(i8 addrspace(200)* null, i64 1)
// CHECK-NEXT:    [[CMP:%.*]] = icmp eq i8 addrspace(200)* [[TMP4]], [[TMP5]]

// CHECK-NEXT:    br i1 [[CMP]], label [[IF_THEN:%.*]], label [[IF_END:%.*]]
// CHECK:       if.then:
// CHECK-NEXT:    [[TMP6:%.*]] = call i8 addrspace(200)* @llvm.cheri.cap.offset.set(i8 addrspace(200)* null, i64 1)
// CHECK-NEXT:    [[TMP7:%.*]] = call i64 @llvm.cheri.cap.offset.get(i8 addrspace(200)* [[TMP6]])
// CHECK-NEXT:    [[NEG:%.*]] = xor i64 [[TMP7]], -1
// CHECK-NEXT:    [[TMP8:%.*]] = call i8 addrspace(200)* @llvm.cheri.cap.offset.set(i8 addrspace(200)* [[TMP6]], i64 [[NEG]])
// CHECK-NEXT:    [[TMP9:%.*]] = load i8 addrspace(200)*, i8 addrspace(200)* addrspace(200)* [[VAL_ADDR]], align 16
// CHECK-NEXT:    [[TMP10:%.*]] = call i64 @llvm.cheri.cap.offset.get(i8 addrspace(200)* [[TMP9]])
// CHECK-NEXT:    [[TMP11:%.*]] = call i64 @llvm.cheri.cap.offset.get(i8 addrspace(200)* [[TMP8]])
// CHECK-NEXT:    [[AND1:%.*]] = and i64 [[TMP10]], [[TMP11]]
// CHECK-NEXT:    [[TMP12:%.*]] = call i8 addrspace(200)* @llvm.cheri.cap.offset.set(i8 addrspace(200)* [[TMP9]], i64 [[AND1]])
// CHECK-NEXT:    store i8 addrspace(200)* [[TMP12]], i8 addrspace(200)* addrspace(200)* [[VAL_ADDR]], align 16
// CHECK-NEXT:    call void @_Z9do_unlockv()
// CHECK-NEXT:    br label [[IF_END]]
// CHECK:       if.end:
// CHECK-NEXT:    ret void
//
extern "C" void unlock(quintptr val) noexcept {
  if ((val & quintptr(1u)) == quintptr(1u)) {
    val &= ~quintptr(1u);
    do_unlock();
  }
}
